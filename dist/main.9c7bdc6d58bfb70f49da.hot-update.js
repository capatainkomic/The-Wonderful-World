"use strict";
/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdatethe_wonderful_world"]("main",{

/***/ "./src/entities/players/HeroController.ts":
/*!************************************************!*\
  !*** ./src/entities/players/HeroController.ts ***!
  \************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   HeroController: () => (/* binding */ HeroController)\n/* harmony export */ });\n/* harmony import */ var _babylonjs_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @babylonjs/core */ \"./node_modules/@babylonjs/core/index.js\");\n/* harmony import */ var _utils_AnimationManager__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../utils/AnimationManager */ \"./src/utils/AnimationManager.ts\");\n/* harmony import */ var _EnemyTest__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./EnemyTest */ \"./src/entities/players/EnemyTest.ts\");\nvar __awaiter = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\n\n\n\nvar HeroState;\n(function (HeroState) {\n    HeroState[\"IDLE\"] = \"idle\";\n    HeroState[\"RUNNING\"] = \"running\";\n    HeroState[\"JUMPING\"] = \"jumping\";\n    HeroState[\"ATTACKING\"] = \"attacking\";\n    HeroState[\"DEFENDING\"] = \"defending\";\n})(HeroState || (HeroState = {}));\nconst HERO_CONFIG = {\n    MOVE_SPEED: 0.1,\n    JUMP_IMPULSE: 5,\n    ATTACK_COOLDOWN_MS: 1500,\n    PARTICLE_EMIT_RATE: 300,\n};\nclass HeroController {\n    constructor(scene) {\n        this.heroMesh = null;\n        this.swordMesh = null;\n        this.inputMap = {};\n        this.keyPressed = {};\n        this.animationManager = null;\n        this.currentState = HeroState.IDLE;\n        this.attackCooldown = false;\n        this.isJumping = false;\n        this.isActionLocked = false;\n        this.particleSystem = null;\n        this.camera = null;\n        this.scene = scene;\n        // Physics is already initialized in app.ts\n        this.loadHero();\n        // Temporary enemy for testing\n        this.enemy = new _EnemyTest__WEBPACK_IMPORTED_MODULE_2__.EnemyTest(enemyMesh, this.scene, new _babylonjs_core__WEBPACK_IMPORTED_MODULE_0__.Vector3(5, 1, 5));\n    }\n    loadHero() {\n        return __awaiter(this, void 0, void 0, function* () {\n            try {\n                const result = yield _babylonjs_core__WEBPACK_IMPORTED_MODULE_0__.SceneLoader.ImportMeshAsync(\"\", \"assets/models/hero/\", \"boy_hero_knight.glb\", this.scene);\n                this.heroMesh = result.meshes[0];\n                this.heroMesh.position = new _babylonjs_core__WEBPACK_IMPORTED_MODULE_0__.Vector3(0, 2, 0);\n                // Create physics impostor for hero\n                this.heroMesh.physicsImpostor = new _babylonjs_core__WEBPACK_IMPORTED_MODULE_0__.PhysicsImpostor(this.heroMesh, _babylonjs_core__WEBPACK_IMPORTED_MODULE_0__.PhysicsImpostor.BoxImpostor, { mass: 1, restitution: 0, friction: 0.5 }, this.scene);\n                // Create ground\n                const ground = _babylonjs_core__WEBPACK_IMPORTED_MODULE_0__.MeshBuilder.CreateBox(\"ground\", { width: 50, height: 1, depth: 50 }, this.scene);\n                ground.position.y = -0.5;\n                ground.physicsImpostor = new _babylonjs_core__WEBPACK_IMPORTED_MODULE_0__.PhysicsImpostor(ground, _babylonjs_core__WEBPACK_IMPORTED_MODULE_0__.PhysicsImpostor.BoxImpostor, { mass: 0, restitution: 0, friction: 0.5 }, this.scene);\n                this.animationManager = new _utils_AnimationManager__WEBPACK_IMPORTED_MODULE_1__.AnimationManager(result.animationGroups, this.scene);\n                this.swordMesh = this.heroMesh.getChildMeshes().find(m => m.name.toLowerCase().includes(\"sword\")) || null;\n                this.transitionToState(HeroState.IDLE);\n                this.createAttackParticles();\n                this.setupCamera();\n                this.setupInput();\n                this.scene.onBeforeRenderObservable.add(() => this.update());\n            }\n            catch (error) {\n                console.error(\"Failed to load hero mesh:\", error);\n            }\n        });\n    }\n    setupCamera() {\n        this.camera = new _babylonjs_core__WEBPACK_IMPORTED_MODULE_0__.FreeCamera(\"camera\", new _babylonjs_core__WEBPACK_IMPORTED_MODULE_0__.Vector3(0, 5, -10), this.scene);\n        this.camera.attachControl(this.scene.getEngine().getRenderingCanvas(), true);\n        this.camera.lockedTarget = this.heroMesh;\n        this.scene.activeCamera = this.camera;\n    }\n    setupInput() {\n        this.scene.actionManager = new _babylonjs_core__WEBPACK_IMPORTED_MODULE_0__.ActionManager(this.scene);\n        this.scene.actionManager.registerAction(new _babylonjs_core__WEBPACK_IMPORTED_MODULE_0__.ExecuteCodeAction(_babylonjs_core__WEBPACK_IMPORTED_MODULE_0__.ActionManager.OnKeyDownTrigger, (evt) => {\n            const rawKey = evt.sourceEvent.key;\n            let key = rawKey.toLowerCase().trim();\n            if (key === \"arrowup\")\n                key = \"w\";\n            if (key === \"arrowdown\")\n                key = \"s\";\n            if (key === \"arrowleft\")\n                key = \"a\";\n            if (key === \"arrowright\")\n                key = \"d\";\n            this.inputMap[key] = true;\n            if (!this.keyPressed[key] && !this.isActionLocked) {\n                this.keyPressed[key] = true;\n                if (this.currentState === HeroState.IDLE || this.currentState === HeroState.RUNNING) {\n                    if (key === \" \" && !this.isJumping) {\n                        this.isJumping = true;\n                        this.isActionLocked = true;\n                        this.transitionToState(HeroState.JUMPING);\n                    }\n                    else if (key === \"f\" && !this.attackCooldown) {\n                        this.isActionLocked = true;\n                        this.transitionToState(HeroState.ATTACKING);\n                    }\n                    else if (key === \"g\") {\n                        this.isActionLocked = true;\n                        this.transitionToState(HeroState.DEFENDING);\n                    }\n                }\n            }\n        }));\n        this.scene.actionManager.registerAction(new _babylonjs_core__WEBPACK_IMPORTED_MODULE_0__.ExecuteCodeAction(_babylonjs_core__WEBPACK_IMPORTED_MODULE_0__.ActionManager.OnKeyUpTrigger, (evt) => {\n            let key = evt.sourceEvent.key.toLowerCase().trim();\n            if (key === \"arrowup\")\n                key = \"w\";\n            if (key === \"arrowdown\")\n                key = \"s\";\n            if (key === \"arrowleft\")\n                key = \"a\";\n            if (key === \"arrowright\")\n                key = \"d\";\n            this.inputMap[key] = false;\n            this.keyPressed[key] = false;\n        }));\n    }\n    createAttackParticles() {\n        const particleSystem = new _babylonjs_core__WEBPACK_IMPORTED_MODULE_0__.ParticleSystem(\"attackParticles\", 200, this.scene);\n        particleSystem.particleTexture = new _babylonjs_core__WEBPACK_IMPORTED_MODULE_0__.Texture(\"https://playground.babylonjs.com/textures/flare.png\", this.scene);\n        particleSystem.emitter = this.heroMesh;\n        particleSystem.minEmitBox = new _babylonjs_core__WEBPACK_IMPORTED_MODULE_0__.Vector3(0, 1, 0.5);\n        particleSystem.maxEmitBox = new _babylonjs_core__WEBPACK_IMPORTED_MODULE_0__.Vector3(0, 1, 0.5);\n        particleSystem.color1 = new _babylonjs_core__WEBPACK_IMPORTED_MODULE_0__.Color4(1, 0, 0, 1);\n        particleSystem.color2 = new _babylonjs_core__WEBPACK_IMPORTED_MODULE_0__.Color4(1, 1, 0, 1);\n        particleSystem.colorDead = new _babylonjs_core__WEBPACK_IMPORTED_MODULE_0__.Color4(0, 0, 0, 0);\n        particleSystem.minSize = 0.1;\n        particleSystem.maxSize = 0.5;\n        particleSystem.minLifeTime = 0.1;\n        particleSystem.maxLifeTime = 0.3;\n        particleSystem.emitRate = HERO_CONFIG.PARTICLE_EMIT_RATE;\n        particleSystem.blendMode = _babylonjs_core__WEBPACK_IMPORTED_MODULE_0__.ParticleSystem.BLENDMODE_ONEONE;\n        particleSystem.gravity = new _babylonjs_core__WEBPACK_IMPORTED_MODULE_0__.Vector3(0, -9.81, 0);\n        particleSystem.direction1 = new _babylonjs_core__WEBPACK_IMPORTED_MODULE_0__.Vector3(-1, 0, 1);\n        particleSystem.direction2 = new _babylonjs_core__WEBPACK_IMPORTED_MODULE_0__.Vector3(1, 0, -1);\n        particleSystem.minAngularSpeed = 0;\n        particleSystem.maxAngularSpeed = Math.PI;\n        particleSystem.minEmitPower = 1;\n        particleSystem.maxEmitPower = 3;\n        particleSystem.updateSpeed = 0.01;\n        this.particleSystem = particleSystem;\n    }\n    update() {\n        if (!this.heroMesh || !this.animationManager || !this.heroMesh.physicsImpostor)\n            return;\n        const moveDirection = new _babylonjs_core__WEBPACK_IMPORTED_MODULE_0__.Vector3(0, 0, 0);\n        let moving = false;\n        if (!this.isActionLocked) {\n            if (this.inputMap[\"w\"]) {\n                moveDirection.z += 1;\n                moving = true;\n            }\n            if (this.inputMap[\"s\"]) {\n                moveDirection.z -= 1;\n                moving = true;\n            }\n            if (this.inputMap[\"a\"]) {\n                moveDirection.x -= 1;\n                moving = true;\n            }\n            if (this.inputMap[\"d\"]) {\n                moveDirection.x += 1;\n                moving = true;\n            }\n        }\n        if (moving) {\n            moveDirection.normalize().scaleInPlace(HERO_CONFIG.MOVE_SPEED);\n            this.heroMesh.moveWithCollisions(moveDirection);\n            this.heroMesh.rotation.y = Math.atan2(moveDirection.x, moveDirection.z);\n            if (this.currentState !== HeroState.JUMPING) {\n                this.transitionToState(HeroState.RUNNING);\n            }\n        }\n        else if (!this.isActionLocked && this.currentState !== HeroState.JUMPING) {\n            this.transitionToState(HeroState.IDLE);\n        }\n        if (this.isJumping) {\n            const velocityY = this.heroMesh.physicsImpostor.getLinearVelocity().y;\n            if (Math.abs(velocityY) > 2.0) {\n                this.animationManager.play(\"jumpairnormal\", false);\n            }\n            else if (Math.abs(velocityY) <= 2.0 && this.currentState === HeroState.JUMPING) {\n                this.isJumping = false;\n                this.isActionLocked = false;\n                this.animationManager.play(\"jumpendnormal\", false, () => {\n                    this.transitionToState(HeroState.IDLE);\n                });\n            }\n        }\n    }\n    transitionToState(newState) {\n        var _a;\n        if (this.currentState === newState || !this.animationManager)\n            return;\n        this.currentState = newState;\n        switch (newState) {\n            case HeroState.IDLE:\n                this.isActionLocked = false;\n                this.isJumping = false;\n                this.animationManager.play(\"idlenormal\");\n                break;\n            case HeroState.RUNNING:\n                if (this.inputMap[\"w\"])\n                    this.animationManager.play(\"runfowardbattle\");\n                else if (this.inputMap[\"s\"])\n                    this.animationManager.play(\"movebackwardbattle\");\n                else if (this.inputMap[\"a\"])\n                    this.animationManager.play(\"moveleftbattle\");\n                else if (this.inputMap[\"d\"])\n                    this.animationManager.play(\"moverightbattle\");\n                break;\n            case HeroState.JUMPING:\n                const jumpAnim = this.animationManager.getAvailableAnimations().includes(\"jumpstartnormal\") ? \"jumpstartnormal\" : \"jumpfullnormal\";\n                this.animationManager.play(jumpAnim, false, () => {\n                    if (this.isJumping) {\n                        this.animationManager.play(\"jumpairnormal\", false);\n                    }\n                });\n                this.heroMesh.physicsImpostor.applyImpulse(new _babylonjs_core__WEBPACK_IMPORTED_MODULE_0__.Vector3(0, HERO_CONFIG.JUMP_IMPULSE, 0), this.heroMesh.getAbsolutePosition());\n                break;\n            case HeroState.ATTACKING:\n                this.attackCooldown = true;\n                const attacks = [\"attack 1\", \"attack 2\", \"attack 3\", \"attack 4\"];\n                const randomAttack = attacks[Math.floor(Math.random() * attacks.length)];\n                this.animationManager.play(randomAttack, false, () => {\n                    this.isActionLocked = false;\n                    this.transitionToState(HeroState.IDLE);\n                });\n                (_a = this.particleSystem) === null || _a === void 0 ? void 0 : _a.start();\n                if (_babylonjs_core__WEBPACK_IMPORTED_MODULE_0__.Vector3.Distance(this.heroMesh.position, this.enemy.mesh.position) <= HERO_CONFIG.ATTACK_RANGE) {\n                    this.enemy.takeDamage(20);\n                }\n                setTimeout(() => {\n                    var _a;\n                    (_a = this.particleSystem) === null || _a === void 0 ? void 0 : _a.stop();\n                    this.attackCooldown = false;\n                }, HERO_CONFIG.ATTACK_COOLDOWN_MS);\n                break;\n            case HeroState.DEFENDING:\n                this.animationManager.play(\"defend\", false, () => {\n                    this.isActionLocked = false;\n                    this.transitionToState(HeroState.IDLE);\n                });\n                break;\n        }\n    }\n}\n\n\n//# sourceURL=webpack://the-wonderful-world/./src/entities/players/HeroController.ts?");

/***/ })

},
/******/ function(__webpack_require__) { // webpackRuntimeModules
/******/ /* webpack/runtime/getFullHash */
/******/ (() => {
/******/ 	__webpack_require__.h = () => ("e285501b6e00138869a6")
/******/ })();
/******/ 
/******/ }
);